function [s_gps, s_acc, s_info] = parse_vscatola_log(file_in, varargin)
% Patrucco, 2020
% Parse internal logs generated by Arduino V-Scatola application.

s_gps = struct('t', [], 'time_utc_str', [], 'isactive', [], 'lat', [], ...
    'lon', [], 'v_kts', [], 'course', [], 'date_str', [], 'mvar', [], ...
    'Time', []);
fnames_gps = fieldnames(s_gps);
s_acc = struct('t', [], 'ax', [], 'ay', [], 'az', [], 'rx', [], 'ry', [], ...
    'rz', []);

if ~isempty(varargin)
    n_lines = varargin{1};
else
    n_lines = Inf;
end

fh1 = fopen(file_in, 'r');
keep_parsing = true;
parsed_lines = 0;

while keep_parsing
    l = fgetl(fh1);
    parsed_lines = parsed_lines + 1;
    if ((~ischar(l)) || parsed_lines >= n_lines)
        keep_parsing = false;
        break;
    else
        %disp(l);
        if contains(l, 'ACC')
            try
            [t, ax, ay, az, rx, ry, rz] = parse_vsc_acc(l);
            s_acc.t = [s_acc.t; t];
            s_acc.ax = [s_acc.ax; ax];
            s_acc.ay = [s_acc.ay; ay];
            s_acc.az = [s_acc.az; az];
            s_acc.rx = [s_acc.rx; rx];
            s_acc.ry = [s_acc.ry; ry];
            s_acc.rz = [s_acc.rz; rz];
            catch
                warning('Unrecognized or irregular ACC string');
            end
        elseif contains(l, 'GPS')
            try
            [t, time_utc_str, isactive, lat, lon, v_kts, course, date_str, mvar, Time] = parse_vsc_gps(l);
            s_gps.t = [s_gps.t; t];
            s_gps.time_utc_str = [s_gps.time_utc_str; {time_utc_str}];
            s_gps.date_str = [s_gps.date_str; {date_str}];
            s_gps.isactive = [s_gps.isactive; isactive];
            s_gps.lat = [s_gps.lat; lat];
            s_gps.lon = [s_gps.lon; lon];
            s_gps.v_kts = [s_gps.v_kts; v_kts];
            s_gps.course = [s_gps.course; course];
            s_gps.mvar = [s_gps.mvar; mvar];
            s_gps.Time = [s_gps.Time; Time];
            catch
                warning('Unrecognized or irregular GPS string');
            end
        end
        %keyboard;
    end
end

s_info.parsed_lines = parsed_lines;
s_info.MinGpsTime = min(s_gps.Time);
s_info.MaxGpsTime = max(s_gps.Time);
s_info.MinGpsTimeStr = datestr(min(s_gps.Time), 'yyyy_mm_dd_HH_MM_SS');
s_info.MaxGpsTimeStr = datestr(max(s_gps.Time), 'yyyy_mm_dd_HH_MM_SS');
s_info.StartGpsDateTime = datetime(min(s_gps.Time), 'ConvertFrom', 'datenum');
s_info.EndGpsDateTime = datetime(max(s_gps.Time), 'ConvertFrom', 'datenum');
s_info.StartGpsDate_Year = s_info.StartGpsDateTime.Year;
s_info.StartGpsDate_Month = s_info.StartGpsDateTime.Month;
s_info.StartGpsDate_Day = s_info.StartGpsDateTime.Day;
s_info.StartGpsDate_Hour = s_info.StartGpsDateTime.Hour;
s_info.StartGpsDate_Minute = s_info.StartGpsDateTime.Minute;
s_info.StartGpsDate_Second = s_info.StartGpsDateTime.Second;
s_info.EndGpsDate_Year = s_info.EndGpsDateTime.Year;
s_info.EndGpsDate_Month = s_info.EndGpsDateTime.Month;
s_info.EndGpsDate_Day = s_info.EndGpsDateTime.Day;
s_info.EndGpsDate_Hour = s_info.EndGpsDateTime.Hour;
s_info.EndGpsDate_Minute = s_info.EndGpsDateTime.Minute;
s_info.EndGpsDate_Second = s_info.EndGpsDateTime.Second;
s_info.Duration_s = max(s_acc.t);
s_info.GpsFrequencyMedian = 1 / median(diff(s_gps.t));
s_info.AccFrequencyMedian = 1 / median(diff(s_acc.t));
s_info.MaxSpeedKmh = 1.852 * max(s_gps.v_kts);
lat_nonan = s_gps.lat(~isnan(s_gps.lat));
lon_nonan = s_gps.lon(~isnan(s_gps.lon));
s_info.StartLat = lat_nonan(1);
s_info.StartLon = lon_nonan(1);
s_info.EndLat = lat_nonan(end);
s_info.EndLon = lon_nonan(end);



fclose(fh1);